use std::collections::HashMap;

use super::TypeGenerator;
use crate::modules::typegen::schema::{LiteralValue, SchemaNode, StepDefinition, StepType, StreamDefinition};

pub struct TypeScriptGenerator;

impl TypeGenerator for TypeScriptGenerator {
    fn generate(&self, steps: &[StepDefinition], streams: &[StreamDefinition]) -> String {
        let handlers = self.generate_handlers(steps);
        let stream_types = self.generate_streams(streams);

        format!(
            r#"/**
 * Automatically generated types for motia
 * Do NOT edit this file manually.
 *
 * Consider adding this file to .prettierignore and eslint ignore.
 */
import {{ EventHandler, ApiRouteHandler, ApiResponse, MotiaStream, CronHandler }} from '@iii-dev/motia'

declare module '@iii-dev/motia' {{
  interface FlowContextStateStreams {{
{}
  }}

  interface Handlers {{
{}
  }}
}}
"#,
            stream_types, handlers
        )
    }
}

impl TypeScriptGenerator {
    fn generate_handlers(&self, steps: &[StepDefinition]) -> String {
        let mut lines = Vec::new();

        for step in steps {
            let handler_type = match &step.step_type {
                StepType::Api { .. } => {
                    let body_type = step
                        .body_schema
                        .as_ref()
                        .map(|s| self.schema_to_typescript(s))
                        .unwrap_or_else(|| "Record<string, unknown>".to_string());

                    let response_type = self.generate_response_union(&step.response_schemas);
                    let emits_type = self.generate_emits_type(&step.emits);

                    format!(
                        "ApiRouteHandler<{}, {}, {}>",
                        body_type, response_type, emits_type
                    )
                }
                StepType::Event => {
                    let input_type = step
                        .body_schema
                        .as_ref()
                        .map(|s| self.schema_to_typescript(s))
                        .unwrap_or_else(|| "never".to_string());

                    let emits_type = self.generate_emits_type(&step.emits);

                    format!("EventHandler<{}, {}>", input_type, emits_type)
                }
                StepType::Cron { .. } => {
                    let emits_type = self.generate_emits_type(&step.emits);
                    format!("CronHandler<{}>", emits_type)
                }
            };

            lines.push(format!("    {}: {}", step.name, handler_type));
        }

        lines.join("\n")
    }

    fn generate_streams(&self, streams: &[StreamDefinition]) -> String {
        let mut lines = Vec::new();

        for stream in streams {
            tracing::debug!("Generating stream '{}' with schema: {:?}", stream.name, stream.schema);
            let schema_type = self.schema_to_typescript(&stream.schema);
            tracing::debug!("Generated TypeScript type for '{}': {}", stream.name, schema_type);
            lines.push(format!("    {}: MotiaStream<{}>", stream.name, schema_type));
        }

        lines.join("\n")
    }

    fn generate_response_union(&self, schemas: &HashMap<u16, SchemaNode>) -> String {
        if schemas.is_empty() {
            return "unknown".to_string();
        }

        let mut responses: Vec<_> = schemas
            .iter()
            .map(|(status, schema)| {
                let body_type = self.schema_to_typescript(schema);
                format!("ApiResponse<{}, {}>", status, body_type)
            })
            .collect();

        responses.sort();

        if responses.len() == 1 {
            responses[0].clone()
        } else {
            responses.join(" | ")
        }
    }

    fn generate_emits_type(&self, emits: &[String]) -> String {
        if emits.is_empty() {
            "never".to_string()
        } else {
            "never".to_string()
        }
    }

    fn schema_to_typescript(&self, schema: &SchemaNode) -> String {
        match schema {
            SchemaNode::String => "string".to_string(),
            SchemaNode::Number => "number".to_string(),
            SchemaNode::Boolean => "boolean".to_string(),
            SchemaNode::Null => "null".to_string(),
            SchemaNode::Never => "never".to_string(),
            SchemaNode::Unknown => "unknown".to_string(),
            SchemaNode::Array(inner) => {
                format!("{}[]", self.schema_to_typescript(inner))
            }
            SchemaNode::Optional(inner) => {
                format!("{} | undefined", self.schema_to_typescript(inner))
            }
            SchemaNode::Union(variants) => {
                let types: Vec<_> = variants
                    .iter()
                    .map(|v| self.schema_to_typescript(v))
                    .collect();
                types.join(" | ")
            }
            SchemaNode::Literal(lit) => match lit {
                LiteralValue::String(s) => format!("\"{}\"", s.replace('\"', "\\\"")),
                LiteralValue::Number(n) => n.to_string(),
                LiteralValue::Boolean(b) => b.to_string(),
            },
            SchemaNode::Object {
                properties,
                additional_properties: _,
            } => {
                if properties.is_empty() {
                    return "Record<string, unknown>".to_string();
                }

                let mut props = Vec::new();
                for (key, prop) in properties {
                    let type_str = self.schema_to_typescript(&prop.schema);
                    let optional_marker = if prop.optional { "?" } else { "" };
                    props.push(format!("{}{}: {}", key, optional_marker, type_str));
                }

                format!("{{ {} }}", props.join("; "))
            }
        }
    }
}

